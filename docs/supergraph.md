## GraphQL::Stitching::Supergraph

A `Supergraph` is the singuar representation of a stitched graph. `Supergraph` is generated by a [`Composer`](./composer.md), and contains the combined schema and delegation map for location routing.

```ruby
storefronts_sdl = "type Query { storefront(id: ID!): Storefront } ..."
products_sdl = "type Query { product(id: ID!): Product } ..."

supergraph = GraphQL::Stitching::Composer.new({
  "storefronts" => GraphQL::Schema.from_definition(storefronts_sdl),
  "products" => GraphQL::Schema.from_definition(products_sdl),
}).perform

combined_schema = supergraph.schema
```

### Assigning executables

A Supergraph also manages executable resources assigned for each location (ie: the objects that perform GraphQL requests for each location). An executable is a `GraphQL::Schema` class or any object that implements a `.call(location, query_string, variables)` method and returns a raw GraphQL response. Executables are assigned to a supergraph using `assign_executable`:

```ruby
supergraph = GraphQL::Stitching::Composer.new(...)

supergraph.assign_executable("location1", MyExecutable.new)
supergraph.assign_executable("location2", ->(loc, query, vars) { ... })
supergraph.assign_executable("location3") do |loc, query vars|
  # ...
end
```

### Export and caching

A Supergraph is designed to be composed, cached, and restored. Calling the `export` method will return an SDL (Schema Definition Language) print of the combined graph schema and a deletation mapping hash. These can be persisted in any raw format that suits your stack:

```ruby
supergraph_sdl, delegation_map = supergraph.export

# stash these resources in Redis...
$redis.set("cached_supergraph_sdl", supergraph_sdl)
$redis.set("cached_delegation_map", JSON.generate(delegation_map))

# or, write the resources as files and commit them to your repo...
File.write("supergraph/schema.graphql", supergraph_sdl)
File.write("supergraph/delegation_map.json", JSON.generate(delegation_map))
```

To restore a cached Supergraph, collect the cached SDL and delegation mapping then recreate the Supergraph using `from_export`:

```ruby
supergraph_sdl = $redis.get("cached_supergraph_sdl")
delegation_map = JSON.parse($redis.get("cached_delegation_map"))

supergraph = GraphQL::Stitching::Supergraph.from_export(supergraph_sdl, delegation_map)
```

Note that a supergraph built from cache will not have _any_ executables assigned to it, so you'll need to manually reassign executables for each location:

```ruby
remote_client = GraphQL::Stitching::RemoteClient.new(
  url: "http:localhost:3000",
  headers: { "Authorization" => "Bearer 12345" }
)
supergraph.assign_executable("my_remote", remote_client)
supergraph.assign_executable("my_local", MyLocal::Schema)
```
