## GraphQL::Stitching::Supergraph

A `Supergraph` is the singuar representation of a stitched graph. `Supergraph` is generated by a [`Composer`](./composer.md), and contains the combined schema and a delegation map of routing locations.

```ruby
storefronts_sdl = "type Query { storefront(id: ID!): Storefront } ..."
products_sdl = "type Query { product(id: ID!): Product } ..."

supergraph = GraphQL::Stitching::Composer.new({
  "storefronts" => GraphQL::Schema.from_definition(storefronts_sdl),
  "products" => GraphQL::Schema.from_definition(products_sdl),
}).perform

combined_schema = supergraph.schema
```

### Assigning executable resources

When a supergraph is composed, it is provided with all of the composed source schemas as its default executable resources (ie: schemas that implement resolvers) and will call `execute` on these schemas to collect data. You can customize the assignment of subgraph resources for the supergraph:

```ruby
# Add a GraphQL::Schema class to execute for the resource
supergraph.assign_location_schema("products", GraphApi::ProductSchema)

# Point the resource at a remote URL
supergraph.assign_location_url("storefronts", "http:localhost:3000", { "Authorization" => "Bearer 12345"})

# Or add a completely custom handler for fetching the resource
supergraph.assign_location_handler("manufacturers") do |location, document, variables|
  # request this resource any way that you'd like!
end
```

### Querying

A `Supergraph` provides an `execute` method that may be used like a normal `GraphQL::Schema` method:

```ruby
document = %{
  query GetStuff($id1: ID!, $id2: ID!) {
    fromLocationA(id: $id1) { sfoo }
    fromLocationB(id: $id2) { bar }
  }
}

result = supergraph.execute(
  query: document,
  variables: { id1: "1", id2: "2" },
  operation_name: "GetStuff"
)
```

# @todo ^^ really?

### Export and caching

The Supergraph is designed to be cacheable so that it can be composed, cached, and restored. Calling the `export` method will return an SDL (Schema Definition Language) print of the combined graph and a simple hash of the deletation maps. These can be persisted in any raw format that suits your stack:

```ruby
graph_sdl, delegation_map = supergraph.export

$redis.set("cached_graph_sdl", graph_sdl)
$redis.set("cached_delegation_map", JSON.generate(delegation_map))
```

To restore a cached graph, collect the cached SDL and delegation maps and recreate the Supergraph using `from_export`:

```ruby
graph_sdl = $redis.get("cached_graph_sdl")
delegation_map = $redis.get("cached_delegation_map")

supergraph = GraphQL::Stitching::Supergraph.from_export(graph_sdl, JSON.parse(delegation_map))
```

Note that a supergraph built from cache will _not_ have any executable resources assigned to it, so you'll need to manually restore the desired executable resources while rehydrating the graph:

```ruby
supergraph.assign_location_schema("products", GraphApi::ProductSchema)
supergraph.assign_location_url("storefronts", "http:localhost:3000", { "Authorization" => "Bearer 12345"})
```
